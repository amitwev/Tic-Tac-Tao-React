{"ast":null,"code":"import Status from './Status';\nexport default {\n  availableSpotsOnArray(boardCards) {\n    let availableSpots = [];\n\n    for (let i = 0; i < boardCards.length; i++) {\n      if (boardCards[i] >= 0 && boardCards[i] < 9) {\n        availableSpots.push(i);\n      }\n    }\n\n    return availableSpots;\n  },\n\n  MinimaxFunctionForAi(newBoard, isComputer) {\n    // Check if there are available spots on board\n    let availableSpots = this.availableSpotsOnArray(newBoard); //Checking if there is a winner\n\n    if (Status.someoneIsWinner(newBoard) === 'X') {\n      return {\n        score: -10\n      };\n    } else if (Status.someoneIsWinner(newBoard) === 'O') {\n      return {\n        score: 10\n      };\n    } else if (availableSpots.length === 0) {\n      return {\n        score: 0\n      };\n    }\n\n    let moves = []; //Looping to find the all the possibilities\n\n    for (let i = 0; i < availableSpots.length; i++) {\n      let move = {};\n      move['index'] = newBoard[availableSpots[i]];\n      isComputer ? newBoard[availableSpots[i]] = 'O' : newBoard[availableSpots[i]] = 'X';\n\n      if (isComputer) {\n        //Computer Player\n        let result = this.MinimaxFunctionForAi(newBoard, false);\n        move.score = result.score;\n      } else {\n        //Human player\n        let result = this.MinimaxFunctionForAi(newBoard, true);\n        move.score = result.score;\n      }\n\n      newBoard[availableSpots[i]] = move.index;\n      moves.push(move);\n    } //Checking for the best move for computer \n\n\n    let bestMove;\n\n    if (isComputer) {\n      let bestScore = -1000;\n\n      for (let i = 0; i < moves.length; i++) {\n        if (moves[i].score > bestScore) {\n          bestScore = moves[i].score;\n          bestMove = i;\n        }\n      }\n    } else {\n      let bestScore = 1000;\n\n      for (let i = 0; i < moves.length; i++) {\n        if (moves[i].score < bestScore) {\n          bestScore = moves[i].score;\n          bestMove = i;\n        }\n      }\n    } //Returning best move object\n\n\n    return moves[bestMove];\n  }\n\n};","map":{"version":3,"sources":["D:/My Personal Projects/TicTacTao-React/client/src/Components/GameLogic/AIComputer.js"],"names":["Status","availableSpotsOnArray","boardCards","availableSpots","i","length","push","MinimaxFunctionForAi","newBoard","isComputer","someoneIsWinner","score","moves","move","result","index","bestMove","bestScore"],"mappings":"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","sourcesContent":["import Status from './Status';\r\nexport default {\r\n    availableSpotsOnArray(boardCards){\r\n        let availableSpots = []; \r\n        for (let i = 0; i < boardCards.length; i++) {\r\n            if(boardCards[i] >= 0 && boardCards[i] < 9){\r\n                availableSpots.push(i)\r\n            }\r\n        }\r\n        return availableSpots;\r\n    },\r\n    MinimaxFunctionForAi(newBoard, isComputer){\r\n        // Check if there are available spots on board\r\n        let availableSpots = this.availableSpotsOnArray(newBoard);\r\n        //Checking if there is a winner\r\n        if(Status.someoneIsWinner(newBoard) === 'X'){\r\n            return { score: -10 };\r\n        }else if(Status.someoneIsWinner(newBoard) === 'O'){\r\n            return { score: 10 };\r\n        }else if(availableSpots.length === 0){\r\n            return{ score: 0 };            \r\n        }\r\n        let moves = [];\r\n        //Looping to find the all the possibilities\r\n        for (let i = 0; i < availableSpots.length; i++) {\r\n            let move = {}; \r\n            move['index'] = newBoard[availableSpots[i]];\r\n            isComputer ? newBoard[availableSpots[i]] = 'O' : newBoard[availableSpots[i]] = 'X';\r\n            if(isComputer){\r\n                //Computer Player\r\n                let result = this.MinimaxFunctionForAi(newBoard, false);\r\n                move.score = result.score; \r\n            }else{\r\n                //Human player\r\n                let result = this.MinimaxFunctionForAi(newBoard, true);\r\n                move.score = result.score;\r\n            }\r\n            newBoard[availableSpots[i]] = move.index; \r\n            moves.push(move);          \r\n        }\r\n        //Checking for the best move for computer \r\n        let bestMove; \r\n        if(isComputer){\r\n            let bestScore = -1000;\r\n            for (let i = 0; i < moves.length; i++) {\r\n                if(moves[i].score > bestScore){\r\n                    bestScore = moves[i].score;\r\n                    bestMove = i;\r\n                }                \r\n            }\r\n        }else{\r\n            let bestScore = 1000;\r\n            for (let i = 0; i < moves.length; i++) {\r\n                if(moves[i].score < bestScore){\r\n                    bestScore = moves[i].score;\r\n                    bestMove = i;\r\n                }                \r\n            }\r\n        }\r\n        //Returning best move object\r\n        return moves[bestMove];\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}